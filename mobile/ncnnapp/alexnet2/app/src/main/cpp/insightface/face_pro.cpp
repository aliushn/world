/* DO NOT EDIT THIS FILE - it is machine generated */
#include <opencv2/core.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>

#include <net.h>
#include <iostream>
#include <thread>
#include<chrono>

#include "face_pro.h"
#include "insight/interface.h"

using namespace std;

void call_image_play(ANativeWindow* window, cv::Mat frame) {
    if (!window||frame.empty()) {
        return;
    }
    LOGE("call_image_play");
    ANativeWindow_setBuffersGeometry(window, frame.cols, frame.rows, WINDOW_FORMAT_RGBA_8888);
    ANativeWindow_Buffer window_buffer;
    if (ANativeWindow_lock(window, &window_buffer, 0)) {
        LOGE("call call_image_play lock failed ");
        return;
    }

    uint8_t *dst = (uint8_t *) window_buffer.bits;
    int dstStride = window_buffer.stride * 4;
    uint8_t *src = frame.data;
    int srcStride = frame.cols*frame.channels();
    LOGE("绘制 宽%d,高%d,stride:%d", window_buffer.width, window_buffer.height,window_buffer.stride);
    for (int i = 0; i < window_buffer.height; ++i) {
        memcpy(dst + i * dstStride, src + i * srcStride, srcStride);
    }
    ANativeWindow_unlockAndPost(window);
    return;
}

void* frameShowProcessor(void* args){
    //单进程不需要锁
    LOGI("start a frameShow processor:%d",pthread_self());
    FaceEnv* fv=(FaceEnv*)args;
    while(fv->isplaying){

        if(fv->ispause){
            std::this_thread::sleep_for(std::chrono::milliseconds(300));
            continue;
        }
        cv::Mat frame=fv->GetShowFrame();
        LOGI("the frameShow processor got one frame");
        if(frame.empty()){
            LOGI("the frameShow processor got empty frame");
            if (fv->isdetend){
                break;
            }
            continue;
        }
        call_image_play(fv->GetVideoWindow(),frame);
    }
    LOGI("the frameShow processor:%d stopped",pthread_self());

    pthread_exit(nullptr);
}

void* faceDetProcessor(void* args){

    LOGI("start a face det processor:%d",pthread_self());

    FaceEnv* fv=(FaceEnv*)args;

    while(fv->isplaying){

        FrameInfo fm=fv->GetFrame();

        if(fm.frame== nullptr||fm.size<=0||fm.height<=0||fm.width<=0){
            LOGI("faceDetProcessor got null frame");
            if(fv->isend){
                break;
            }
            continue;
        }
        LOGI("det processor:%d got one frame",pthread_self());
        //YUV 420_888转RGBA
        cv::Mat rgbImg(fm.height, fm.width,CV_8UC3);
        {
            cv::Mat yuvImg;
            yuvImg.create(fm.height * 3/2, fm.width, CV_8UC1);
            int fsize=fm.height *fm.width*3/2;  // only copy part of data
            memcpy(yuvImg.data, fm.frame, fsize);
            free(fm.frame); //释放
            cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_NV21);
            yuvImg.release(); //deref 引用数目为0则释放
        }

        if(fm.width>fm.height){
            //旋转90度播放
            //cv::Mat routateImg;
            int tmp=fm.width;
            fm.width=fm.height;
            fm.height=fm.width;
            cv::rotate(rgbImg,rgbImg,cv::ROTATE_90_COUNTERCLOCKWISE);
        }
        ncnn::Mat in =ncnn::Mat::from_pixels_resize(rgbImg.data,ncnn::Mat::PIXEL_BGR,fm.width,fm.height,FACE_DETECT_SIZEH,FACE_DETECT_SIZEH);
        LOGI("VideoDetAndShow width:%d, height:%d,ncnn in dims:%d,empty:%d",in.w,in.h,in.dims,in.empty());
        pthread_mutex_lock(&fv->fdmutex);
        //inference
        vector<FaceInfo> faceinfo = face_detect(in);
        pthread_mutex_unlock(&fv->fdmutex);
        //vector<pair<std::size_t,float > > out;
        int cnt = faceinfo.size();
        CompFaceInfo cpInfo;
        cpInfo.in=rgbImg;
        cpInfo.offset=fm.offset;
        cpInfo.width=fm.width;
        cpInfo.height=fm.height;
        if(cnt)
        {
            for (int i = 0 ; i < cnt&i<2 ; i ++) {
                FaceInfo face = faceinfo[i];
                LOGD("get face %d %d %d %d %f", face.x[0], face.y[0], face.x[1], face.y[1], face.score);

                cpInfo.faces.push_back(face);
                //默认score最大的那个人脸为目标
                //还原到原图
                float widthscale = float(fm.width) / FACE_DETECT_SIZEH;
                float heightscale = float(fm.height) / FACE_DETECT_SIZEH;
                LOGD("VideoDetAndShow get face %d %d %d %d %d %f", cnt, face.x[0], face.y[0], face.x[1],
                     face.y[1], face.score);
                cv::Rect rect(face.x[0] * widthscale, face.y[0] * heightscale,
                              (face.x[1] - face.x[0]) * widthscale,
                              (face.y[1] - face.y[0]) * heightscale);

                cv::rectangle(rgbImg, rect, cv::Scalar(0, 0, 255), 1, cv::LINE_8, 0);
            }
            //获取feature
            //this->target_face_feature=face_exactfeature(in,face);
            //LOGD("get face feature of length:%d",this->target_face_feature.size());
        }

        cv::Mat showroi;
        cv::cvtColor(rgbImg, showroi, cv::COLOR_BGR2RGBA);
        fv->PutShowFrame(showroi);
        if(!cpInfo.faces.empty()){
            fv->PutCompareFace(cpInfo);
        }

        //if cpInfo.faces.isnotempty put to comparequeue
        //put rgbImg to showqueue;

    }

    LOGI("the face det processor:%d stopped",pthread_self());

    pthread_exit(nullptr);
}

void* faceCompareProcessor(void *args){
    //单进程不需要锁
    LOGI("start a face compare processor:%d",pthread_self());

    FaceEnv* fv=(FaceEnv*)args;
    std::vector<float> target=fv->GetTargetFaceFeature();

    while(fv->isplaying) {

        if (fv->ispause&&!target.empty()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(300));
            continue;
        }
        CompFaceInfo cInfo=fv->GetCompareFace();
        if(cInfo.in.empty()||cInfo.faces.empty()){
          LOGI("empty compFaceInfo %d %d",cInfo.in.empty(),cInfo.faces.empty());
          if(fv->isdetend){
              break;
          }
          continue;
        }
        if(target.empty()){
            LOGE("faceCompareProcessor no target face");
            continue;
        }
        ncnn::Mat nin =ncnn::Mat::from_pixels_resize(cInfo.in.data,ncnn::Mat::PIXEL_BGR,cInfo.width,cInfo.height,FACE_DETECT_SIZEH,FACE_DETECT_SIZEH);
        for(auto f:cInfo.faces){
            std::vector<float> trace= face_exactfeature(nin,f);
            float sim=face_calcSimilar(target,trace);
            if(sim>=fv->compare_threshold){
                //默认score最大的那个人脸为目标

                float widthscale = float(cInfo.width)/FACE_DETECT_SIZEH;
                float heightscale =float(cInfo.height)/FACE_DETECT_SIZEH;
                cv::Rect rect(f.x[0]*widthscale,f.y[0]*heightscale,(f.x[1]-f.x[0])*widthscale,(f.y[1]-f.y[0])*heightscale);

                cv::Mat image_roi(cInfo.in,rect);
                cv::Mat roi_g;
                cv::cvtColor(image_roi, roi_g, cv::COLOR_BGR2RGBA);
                LOGD("faceCompareProcessor show %d, %d,type:%d, %f %d %d %d %d %f %d",image_roi.cols,image_roi.rows,image_roi.type(),sim, f.x[0], f.y[0], f.x[1], f.y[1],f.score,cInfo.offset);
                sprintf(fv->trace_text,"frame:%d,sim:%.3f",cInfo.offset,sim);
                call_image_play(fv->GetTraceWindow(),roi_g);
            }
        }
    }

    LOGI("face compare process end");
    pthread_exit(nullptr);
}

FaceEnv::FaceEnv(ANativeWindow* target_surface, ANativeWindow* trace_surface,ANativeWindow* video_surface) {

    target_window= target_surface;
    trace_window= trace_surface;
    video_window= video_surface;

    pthread_mutex_init(&fdmutex, NULL);

    pthread_mutex_init(&smutex, NULL);
    pthread_cond_init(&scond, NULL);

    pthread_mutex_init(&fmutex, NULL);
    pthread_cond_init(&fcond, NULL);

    pthread_mutex_init(&cmutex, NULL);
    pthread_cond_init(&ccond, NULL);

    trace_text=(char *)malloc(50);

    ispause=0;
    isplaying=0;
    isend=0;
    isdetend=0;
    faceCurrentNum=4;
    compare_threshold=0.8;
    //join 会卡在主线程，不要在这里join
}
FaceEnv::~FaceEnv() {
    if(!target_window){
        ANativeWindow_release(target_window);
        target_window= nullptr;
    }
    if(!trace_window){
        ANativeWindow_release(trace_window);
        trace_window= nullptr;
    }
    if(!video_window){
        ANativeWindow_release(video_window);
        video_window= nullptr;
    }
    pthread_mutex_destroy(&fdmutex);

    pthread_mutex_destroy(&smutex);
    pthread_cond_destroy(&scond);

    pthread_cond_destroy(&fcond);
    pthread_mutex_destroy(&fmutex);

    pthread_cond_destroy(&ccond);
    pthread_mutex_destroy(&cmutex);

    free(trace_text);
}

void FaceEnv::PutFrame(FrameInfo f){
    pthread_mutex_lock(&fmutex);
    fqueue.push(f);
    pthread_mutex_unlock(&fmutex);
    LOGI("put one to origin frame queue,cached num:%d",fqueue.size());
    if(fqueue.size()>150){
        std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    }
    //一次只能激活一个等待线程,激活多个pthread_cond_broadcast
    pthread_cond_signal(&fcond);

}
FrameInfo FaceEnv::GetFrame(){
    pthread_mutex_lock(&fmutex);
    if(fqueue.empty()&&isplaying&&!isend){
        LOGI("empty origin frame queue wait");
        pthread_cond_wait(&fcond,&fmutex);
    }else if(fqueue.empty()){
        isdetend=1;
    }

    FrameInfo fn;
    fn.frame=nullptr;
    if(!fqueue.empty()){
        fn=fqueue.front();
        fqueue.pop();
    }
    LOGI("got one from orgin frame queue:%d",fqueue.size());

    pthread_mutex_unlock(&fmutex);
    return fn;
}

void FaceEnv::PutShowFrame(cv::Mat f){
    pthread_mutex_lock(&smutex);
    squeue.push(f);
    pthread_mutex_unlock(&smutex);
    LOGI("put one to show frame queue,cached num:%d",squeue.size());
    //一次只能激活一个等待线程,激活多个pthread_cond_broadcast
    pthread_cond_signal(&scond);

}
cv::Mat FaceEnv::GetShowFrame(){
    pthread_mutex_lock(&smutex);
    if(squeue.empty()&&isplaying&&!isdetend){
        LOGI("empty showframe queue wait");
        pthread_cond_wait(&scond,&smutex);
    }
    cv::Mat fn;
    if(!squeue.empty()){
        fn=squeue.front();
        squeue.pop();
    }
    LOGI("got one from show frame queue:%d",squeue.size());

    pthread_mutex_unlock(&smutex);
    return fn;
}

void FaceEnv::PutCompareFace(CompFaceInfo f){
    pthread_mutex_lock(&cmutex);
    cqueue.push(f);
    pthread_mutex_unlock(&cmutex);
    LOGI("put one to compare queue,cached num:%d",cqueue.size());
    //一次只能激活一个等待线程,激活多个pthread_cond_broadcast,放在lock外面减少内核切换
    pthread_cond_signal(&ccond);
}
CompFaceInfo FaceEnv::GetCompareFace(){
        pthread_mutex_lock(&cmutex);
        if(cqueue.empty()&&isplaying&&!isdetend){
            LOGI("empty compareframe queue wait");
            pthread_cond_wait(&ccond,&cmutex);
        }
        CompFaceInfo fn;
        if(!cqueue.empty()){
            fn=cqueue.front();
            cqueue.pop();
        }
        LOGI("got one from compare queue");
        pthread_mutex_unlock(&cmutex);
        return fn;
}

int FaceEnv::Start() {
    if(isplaying||ispause){
        Stop();
    }

    sprintf(trace_text,"%s","traced face");
    isplaying=1;
    //face det processors
    for(int i=0;i<faceCurrentNum;i++){
        pthread_t*  fpid=new pthread_t;
        pthread_create(fpid, NULL, faceDetProcessor, this);
        fpids.push_back(fpid);
    }

    //face compare processsors
    pthread_create(&cpid, NULL, faceCompareProcessor, this);

    //frame show processors
    pthread_create(&spid, NULL, frameShowProcessor, this);
    LOGI("all processors started!:%s",trace_text);
    return 0;
}

int FaceEnv::Stop() {
    if(isplaying||ispause){
        LOGI("all processors is stopping...");
        if (!isend){//非正常结束
            isplaying=0;
            ispause=0;
        }

        for(int i=0;i<faceCurrentNum;i++){
            pthread_cond_signal(&fcond);
        }

        for(auto iter:fpids) {
            pthread_join(*iter, 0);
            delete iter;
        }
        pthread_cond_signal(&scond);
        pthread_join(spid, 0);
        pthread_cond_signal(&ccond);
        pthread_join(cpid, 0);



        isplaying=0;
        ispause=0;
        isend=0;
        isdetend=0;

        LOGI("all processors stopped");

        for(;!fqueue.empty();){
            FrameInfo fiter=fqueue.front();
            if(fiter.frame!= nullptr){
                free(fiter.frame);
            }
            fqueue.pop();
        }

        for(;!cqueue.empty();){
            cqueue.pop();
        }

        for(;!squeue.empty();){
            squeue.pop();
        }

        for(;!fpids.empty();){
            fpids.pop_back();
        }
    }

    return 0;
}

int FaceEnv::Pause(){
    if(isplaying){
        ispause=!ispause;
    }
    return 0;
}


void FaceEnv::ResetEnv(ANativeWindow* target_surface,ANativeWindow* trace_surface, ANativeWindow* video_surface){
    if(target_surface){
        if(target_window){
            ANativeWindow_release(target_window);
        }
        target_window= target_surface;
        if(!target_face_img.empty()){
            call_image_play(target_window,target_face_img);
        }
    }
    if(trace_surface){
        if(trace_window){
            ANativeWindow_release(trace_window);
        }
        trace_window= trace_surface;
    }
    if(video_surface){
        if(video_window){
            ANativeWindow_release(video_window);
        }
        video_window= video_surface;
    }
    return;
}



char* FaceEnv::DetAndShow(const char *img_path) {
    try {
        LOGE("FaceEnv::DetAndShow,:%s",img_path);
        cv::Mat cvin = cv::imread(img_path, cv::IMREAD_COLOR);
        if(cvin.empty()||cvin.cols<10||cvin.rows<10){
            LOGE("DetAndShow invalid input image,:%s",img_path);
            return "invalid input image";
        }

        if (!target_window) {
            LOGE("null target_window");
            return "null target_window";
        }

        LOGE("cvmat1,:%d,data ptr:%X,cols:%d,rows:%d",cvin.size,cvin.data,cvin.cols,cvin.rows);
        ncnn::Mat in = ncnn::Mat::from_pixels_resize(cvin.data, ncnn::Mat::PIXEL_BGR, cvin.cols, cvin.rows,
                                                     FACE_DETECT_SIZEH, FACE_DETECT_SIZEH);
        //inference
        vector<FaceInfo> faceinfo = face_detect(in);
        //vector<pair<std::size_t,float > > out;
        int cnt = faceinfo.size();
        cv::Mat image_roi;
        if(cnt)
        {
            //默认score最大的那个人脸为目标
            float widthscale = float(cvin.cols)/FACE_DETECT_SIZEH;
            float heightscale =float(cvin.rows)/FACE_DETECT_SIZEH;
            FaceInfo face = faceinfo[0];
            LOGD("get face %d %d %d %d %d %f",cnt, face.x[0], face.y[0], face.x[1], face.y[1],face.score);
            cv::Rect rect(face.x[0]*widthscale,face.y[0]*heightscale,(face.x[1]-face.x[0])*widthscale,(face.y[1]-face.y[0])*heightscale);
            image_roi=cvin(rect);

            //获取feature
            this->target_face_feature=face_exactfeature(in,face);
            LOGD("get face feature of length:%d",this->target_face_feature.size());
        } else{
            LOGE("no target face");
            return "no target face";
        }


        //这一步非常重要,cv::Mat读进来
        cv::Mat ccvin;
        cv::cvtColor(image_roi, ccvin, cv::COLOR_BGR2RGBA);
        this->target_face_img=ccvin;
        LOGD("target face image info: %d, %d, %d",ccvin.cols,ccvin.rows,ccvin.type());
        call_image_play(target_window,ccvin);

    }catch (std::exception& e){
        LOGE("cache exception");
        LOGE("cache exception:%s",e.what());
    }
    return "success";
}

/*
CompFaceInfo FaceEnv::VideoDetAndShow(char* yuv,int size, int width,int height,int offset){


    //YUV 420_888转RGBA
    cv::Mat yuvImg;
    cv::Mat rgbImg(height, width,CV_8UC3);
    yuvImg.create(height * 3/2, width, CV_8UC1);
    memcpy(yuvImg.data, yuv, size);
    cv::cvtColor(yuvImg, rgbImg, CV_YUV2RGBA_NV21);

    LOGI("VideoDetAndShow width:%d, height:%d,size:%d",width,height,size);
    if(video_window== nullptr){
        LOGE("VideoDetAndShow vieo_window null, width:%d, height:%d,size:%d",width,height,size);
        return -1;
    }

    if(width>height){
        //旋转90度播放
        //cv::Mat routateImg
        int tmp=width;
        width=height;
        height=width;
        cv::rotate(rgbImg,rgbImg,cv::ROTATE_90_COUNTERCLOCKWISE);
    }
    ncnn::Mat in =ncnn::Mat::from_pixels_resize(rgbImg.data,ncnn::Mat::PIXEL_RGBA2BGR,width,height,FACE_DETECT_SIZEH,FACE_DETECT_SIZEH);
    LOGI("VideoDetAndShow width:%d, height:%d,ncnn in dims:%d,empty:%d",in.w,in.h,in.dims,in.empty());
    //inference
    vector<FaceInfo> faceinfo = face_detect(in);
    //vector<pair<std::size_t,float > > out;
    int cnt = faceinfo.size();
    LOGI("VideoDetAndShow2 face num:%d",cnt);
    CompFaceInfo cpInfo;
    cpInfo.in=rgbImg;
    cpInfo.offset=offset;
    cpInfo.width=width;
    cpInfo.height=height;
    if(cnt)
    {
        for (int i = 0 ; i < cnt&i<2 ; i ++) {
            FaceInfo face = faceinfo[i];
            LOGD("get face %d %d %d %d %f", face.x[0], face.y[0], face.x[1], face.y[1], face.score);

            cpInfo.faces.push_back(face);
            //默认score最大的那个人脸为目标
            //还原到原图
            float widthscale = float(width) / FACE_DETECT_SIZEH;
            float heightscale = float(height) / FACE_DETECT_SIZEH;
            LOGD("VideoDetAndShow get face %d %d %d %d %d %f", cnt, face.x[0], face.y[0], face.x[1],
                 face.y[1], face.score);
            cv::Rect rect(face.x[0] * widthscale, face.y[0] * heightscale,
                          (face.x[1] - face.x[0]) * widthscale,
                          (face.y[1] - face.y[0]) * heightscale);

            cv::rectangle(rgbImg, rect, cv::Scalar(0, 0, 255), 1, cv::LINE_8, 0);
        }
        //获取feature
        //this->target_face_feature=face_exactfeature(in,face);
        //LOGD("get face feature of length:%d",this->target_face_feature.size());
    }


    free(yuv);

    return cpInfo;
}
 */